// Copyright 2025 The kmesh Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

use std::{
    net::{TcpListener, ToSocketAddrs},
    result::Result as StdResult,
    sync::Arc,
};

use axum::{
    extract::State, http::header::HeaderValue, response::IntoResponse, routing::get, Router,
};
use http::header::CONTENT_TYPE;
use prometheus_client::{
    collector::Collector,
    encoding::{text::encode, DescriptorEncoder, EncodeMetric},
    metrics::{counter::ConstCounter, gauge::ConstGauge},
    registry::Registry,
};
use tower_http::set_header::SetResponseHeaderLayer;
use tracing::{trace, warn};

use super::*;
use crate::Result;

//We create an extra struct here because the prometheus_client api wants a boxed up dyn trait
// object later on.
//
// Not a huge fan of the prometheus_client api, given how simple the file-format used is
// we might be able to roll our own as well and reduce the boilerplate
#[derive(Debug)]
struct ListenerCollector;
impl Collector for ListenerCollector {
    fn encode(&self, mut encoder: DescriptorEncoder) -> StdResult<(), std::fmt::Error> {
        let active = Statistics::listener()
            .active_connections
            .load(Ordering::Relaxed);
        let total = Statistics::listener()
            .total_connections
            .load(Ordering::Relaxed);
        let counter = ConstCounter::new(total);
        counter.encode(encoder.encode_descriptor(
            "connections",
            "all connections",
            None,
            counter.metric_type(),
        )?)?;
        let gauge = ConstGauge::new(active);
        gauge.encode(encoder.encode_descriptor(
            "active_connections",
            "active connections",
            None,
            gauge.metric_type(),
        )?)
    }
}

#[derive(Debug)]
struct HttpCollector;
impl Collector for HttpCollector {
    fn encode(&self, mut encoder: DescriptorEncoder) -> StdResult<(), std::fmt::Error> {
        let gateway_errors = Statistics::http().gateway_errors.load(Ordering::Relaxed);
        let counter = ConstCounter::new(gateway_errors);
        counter.encode(encoder.encode_descriptor(
            "gateway_errors",
            "number of gateway error responses generated by this proxy",
            None,
            counter.metric_type(),
        )?)
    }
}

impl Statistics {
    pub fn register_with_prometheus(registry: &mut Registry) {
        registry
            .sub_registry_with_prefix("listener")
            .register_collector(Box::new(ListenerCollector));
        registry
            .sub_registry_with_prefix("http")
            .register_collector(Box::new(HttpCollector));
    }

    pub fn create_prometheus_register() -> Registry {
        let mut registry = Registry::default();
        Statistics::register_with_prometheus(&mut registry);
        registry
    }
}

pub async fn serve_on(addr: impl ToSocketAddrs) -> Result<()> {
    async fn get_handler(State(registry): State<Arc<Registry>>) -> axum::response::Response {
        trace!("prometheum got pinged");
        let mut buffer = String::new();
        if let Err(e) = encode(&mut buffer, &registry) {
            warn!("failed to encode metrics for prometheus because of error: \"{e}\"");
            (
                axum::http::StatusCode::INTERNAL_SERVER_ERROR,
                format!("{e}"),
            )
                .into_response()
        } else {
            buffer.into_response()
        }
    }
    let registry = Statistics::create_prometheus_register();
    let app = Router::new()
        .route(
            "/metrics",
            get(get_handler).with_state(std::sync::Arc::new(registry)),
        )
        .layer(SetResponseHeaderLayer::overriding(
            CONTENT_TYPE,
            HeaderValue::from_static("text/plain"),
        ));
    let tcp_listener = TcpListener::bind(addr)?;
    axum::Server::from_tcp(tcp_listener)?
        .serve(app.into_make_service())
        .await?;
    Ok(())
}
